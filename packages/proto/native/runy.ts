// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: runy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata as Metadata1,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Struct } from "./google/protobuf/struct.ts";
import { Timestamp } from "./google/protobuf/timestamp.ts";
import { ProcessMetadata } from "./process.ts";
import { ServiceMetadata } from "./service.ts";

export const protobufPackage = "runy";

export interface ReconfigureRequest {
  workspace: string;
  resource: string;
  config: { [key: string]: any } | undefined;
}

export interface ReconfigureResponse {
}

export interface GetResourceRequest {
  workspace: string;
  resource: string;
}

export interface GetResourceResponse {
  process?: ProcessMetadata | undefined;
  service?: ServiceMetadata | undefined;
  config: { [key: string]: any } | undefined;
}

export interface SignalRequest {
  workspace: string;
  resource: string;
  signal: string;
}

export interface SignalResponse {
}

export interface WorkspaceCreateRequest {
  workspace: WorkspaceMetadata | undefined;
}

export interface WorkspaceCreateResponse {
}

export interface WorkspaceRemoveRequest {
  name: string;
}

export interface WorkspaceRemoveResponse {
}

export interface WorkspaceMetadata {
  name: string;
  cwd?: string | undefined;
}

export interface JournalEntriesRequest {
  journal: string;
  ranges: Range[];
}

export interface Range {
  start: number;
  end: number;
}

export interface JournalEntriesResponse {
  entries: { [key: number]: JournalEntry };
}

export interface JournalEntriesResponse_EntriesEntry {
  key: number;
  value: JournalEntry | undefined;
}

export interface JournalEntry {
  ts: number;
  level: number;
  workspace?: string | undefined;
  service?: string | undefined;
  message?: string | undefined;
  fields: Uint8Array;
}

export interface JournalRequest {
  workspace: string;
  service?: string | undefined;
  query?: string | undefined;
}

export interface JournalRecord {
  uuid: string;
  length: number;
}

export interface TreeRequest {
}

export interface TreeResponse {
  workspaces: TreeWorkspace[];
}

export interface TreeWorkspace {
  name: string;
  processes: TreeProcess[];
  services: TreeService[];
}

export interface TreeService {
  name: string;
  flags: number;
  processes: TreeProcess[];
}

export interface TreeProcess {
  name: string;
  pid: number;
  restartCount: number;
  lastRestart?: Date | undefined;
  flags: number;
}

export interface Flag {
  label: string;
  value: { [key: string]: any } | undefined;
}

export interface ExecRequest {
  folder: string;
  watch: boolean;
  uuid?: string | undefined;
  extra?: Uint8Array | undefined;
  start?: StartCommand | undefined;
}

export interface StartCommand {
  workspace: WorkspaceMetadata | undefined;
  process: ProcessMetadata | undefined;
}

export interface ClearJournalRequest {
}

export interface ClearJournalResponse {
}

export interface TerminateRequest {
}

export interface TerminateResponse {
}

export interface VersionRequest {
}

export interface CommandRecord {
  metadata?: Metadata | undefined;
  log?: LogEntry | undefined;
  result?: JsonResult | undefined;
}

export interface JsonResult {
  value: Uint8Array;
  error: JsonError | undefined;
}

export interface JsonError {
  code: string;
  message: string;
  source?: JsonError | undefined;
  backtrace: string[];
}

export interface Metadata {
}

export interface LogEntry {
}

export interface VersionResponse {
  version: string;
}

function createBaseReconfigureRequest(): ReconfigureRequest {
  return { workspace: "", resource: "", config: undefined };
}

export const ReconfigureRequest: MessageFns<ReconfigureRequest> = {
  encode(message: ReconfigureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== "") {
      writer.uint32(10).string(message.workspace);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    if (message.config !== undefined) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconfigureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconfigureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconfigureRequest {
    return {
      workspace: isSet(object.workspace) ? globalThis.String(object.workspace) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      config: isObject(object.config) ? object.config : undefined,
    };
  },

  toJSON(message: ReconfigureRequest): unknown {
    const obj: any = {};
    if (message.workspace !== "") {
      obj.workspace = message.workspace;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.config !== undefined) {
      obj.config = message.config;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconfigureRequest>, I>>(base?: I): ReconfigureRequest {
    return ReconfigureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconfigureRequest>, I>>(object: I): ReconfigureRequest {
    const message = createBaseReconfigureRequest();
    message.workspace = object.workspace ?? "";
    message.resource = object.resource ?? "";
    message.config = object.config ?? undefined;
    return message;
  },
};

function createBaseReconfigureResponse(): ReconfigureResponse {
  return {};
}

export const ReconfigureResponse: MessageFns<ReconfigureResponse> = {
  encode(_: ReconfigureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconfigureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconfigureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReconfigureResponse {
    return {};
  },

  toJSON(_: ReconfigureResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconfigureResponse>, I>>(base?: I): ReconfigureResponse {
    return ReconfigureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconfigureResponse>, I>>(_: I): ReconfigureResponse {
    const message = createBaseReconfigureResponse();
    return message;
  },
};

function createBaseGetResourceRequest(): GetResourceRequest {
  return { workspace: "", resource: "" };
}

export const GetResourceRequest: MessageFns<GetResourceRequest> = {
  encode(message: GetResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== "") {
      writer.uint32(10).string(message.workspace);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourceRequest {
    return {
      workspace: isSet(object.workspace) ? globalThis.String(object.workspace) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
    };
  },

  toJSON(message: GetResourceRequest): unknown {
    const obj: any = {};
    if (message.workspace !== "") {
      obj.workspace = message.workspace;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourceRequest>, I>>(base?: I): GetResourceRequest {
    return GetResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResourceRequest>, I>>(object: I): GetResourceRequest {
    const message = createBaseGetResourceRequest();
    message.workspace = object.workspace ?? "";
    message.resource = object.resource ?? "";
    return message;
  },
};

function createBaseGetResourceResponse(): GetResourceResponse {
  return { process: undefined, service: undefined, config: undefined };
}

export const GetResourceResponse: MessageFns<GetResourceResponse> = {
  encode(message: GetResourceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.process !== undefined) {
      ProcessMetadata.encode(message.process, writer.uint32(10).fork()).join();
    }
    if (message.service !== undefined) {
      ServiceMetadata.encode(message.service, writer.uint32(18).fork()).join();
    }
    if (message.config !== undefined) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.process = ProcessMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.service = ServiceMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourceResponse {
    return {
      process: isSet(object.process) ? ProcessMetadata.fromJSON(object.process) : undefined,
      service: isSet(object.service) ? ServiceMetadata.fromJSON(object.service) : undefined,
      config: isObject(object.config) ? object.config : undefined,
    };
  },

  toJSON(message: GetResourceResponse): unknown {
    const obj: any = {};
    if (message.process !== undefined) {
      obj.process = ProcessMetadata.toJSON(message.process);
    }
    if (message.service !== undefined) {
      obj.service = ServiceMetadata.toJSON(message.service);
    }
    if (message.config !== undefined) {
      obj.config = message.config;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourceResponse>, I>>(base?: I): GetResourceResponse {
    return GetResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResourceResponse>, I>>(object: I): GetResourceResponse {
    const message = createBaseGetResourceResponse();
    message.process = (object.process !== undefined && object.process !== null)
      ? ProcessMetadata.fromPartial(object.process)
      : undefined;
    message.service = (object.service !== undefined && object.service !== null)
      ? ServiceMetadata.fromPartial(object.service)
      : undefined;
    message.config = object.config ?? undefined;
    return message;
  },
};

function createBaseSignalRequest(): SignalRequest {
  return { workspace: "", resource: "", signal: "" };
}

export const SignalRequest: MessageFns<SignalRequest> = {
  encode(message: SignalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== "") {
      writer.uint32(10).string(message.workspace);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    if (message.signal !== "") {
      writer.uint32(26).string(message.signal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signal = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalRequest {
    return {
      workspace: isSet(object.workspace) ? globalThis.String(object.workspace) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      signal: isSet(object.signal) ? globalThis.String(object.signal) : "",
    };
  },

  toJSON(message: SignalRequest): unknown {
    const obj: any = {};
    if (message.workspace !== "") {
      obj.workspace = message.workspace;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.signal !== "") {
      obj.signal = message.signal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalRequest>, I>>(base?: I): SignalRequest {
    return SignalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalRequest>, I>>(object: I): SignalRequest {
    const message = createBaseSignalRequest();
    message.workspace = object.workspace ?? "";
    message.resource = object.resource ?? "";
    message.signal = object.signal ?? "";
    return message;
  },
};

function createBaseSignalResponse(): SignalResponse {
  return {};
}

export const SignalResponse: MessageFns<SignalResponse> = {
  encode(_: SignalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SignalResponse {
    return {};
  },

  toJSON(_: SignalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalResponse>, I>>(base?: I): SignalResponse {
    return SignalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalResponse>, I>>(_: I): SignalResponse {
    const message = createBaseSignalResponse();
    return message;
  },
};

function createBaseWorkspaceCreateRequest(): WorkspaceCreateRequest {
  return { workspace: undefined };
}

export const WorkspaceCreateRequest: MessageFns<WorkspaceCreateRequest> = {
  encode(message: WorkspaceCreateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== undefined) {
      WorkspaceMetadata.encode(message.workspace, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceCreateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspace = WorkspaceMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceCreateRequest {
    return { workspace: isSet(object.workspace) ? WorkspaceMetadata.fromJSON(object.workspace) : undefined };
  },

  toJSON(message: WorkspaceCreateRequest): unknown {
    const obj: any = {};
    if (message.workspace !== undefined) {
      obj.workspace = WorkspaceMetadata.toJSON(message.workspace);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceCreateRequest>, I>>(base?: I): WorkspaceCreateRequest {
    return WorkspaceCreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceCreateRequest>, I>>(object: I): WorkspaceCreateRequest {
    const message = createBaseWorkspaceCreateRequest();
    message.workspace = (object.workspace !== undefined && object.workspace !== null)
      ? WorkspaceMetadata.fromPartial(object.workspace)
      : undefined;
    return message;
  },
};

function createBaseWorkspaceCreateResponse(): WorkspaceCreateResponse {
  return {};
}

export const WorkspaceCreateResponse: MessageFns<WorkspaceCreateResponse> = {
  encode(_: WorkspaceCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WorkspaceCreateResponse {
    return {};
  },

  toJSON(_: WorkspaceCreateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceCreateResponse>, I>>(base?: I): WorkspaceCreateResponse {
    return WorkspaceCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceCreateResponse>, I>>(_: I): WorkspaceCreateResponse {
    const message = createBaseWorkspaceCreateResponse();
    return message;
  },
};

function createBaseWorkspaceRemoveRequest(): WorkspaceRemoveRequest {
  return { name: "" };
}

export const WorkspaceRemoveRequest: MessageFns<WorkspaceRemoveRequest> = {
  encode(message: WorkspaceRemoveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceRemoveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceRemoveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceRemoveRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: WorkspaceRemoveRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceRemoveRequest>, I>>(base?: I): WorkspaceRemoveRequest {
    return WorkspaceRemoveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceRemoveRequest>, I>>(object: I): WorkspaceRemoveRequest {
    const message = createBaseWorkspaceRemoveRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseWorkspaceRemoveResponse(): WorkspaceRemoveResponse {
  return {};
}

export const WorkspaceRemoveResponse: MessageFns<WorkspaceRemoveResponse> = {
  encode(_: WorkspaceRemoveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceRemoveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceRemoveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WorkspaceRemoveResponse {
    return {};
  },

  toJSON(_: WorkspaceRemoveResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceRemoveResponse>, I>>(base?: I): WorkspaceRemoveResponse {
    return WorkspaceRemoveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceRemoveResponse>, I>>(_: I): WorkspaceRemoveResponse {
    const message = createBaseWorkspaceRemoveResponse();
    return message;
  },
};

function createBaseWorkspaceMetadata(): WorkspaceMetadata {
  return { name: "", cwd: undefined };
}

export const WorkspaceMetadata: MessageFns<WorkspaceMetadata> = {
  encode(message: WorkspaceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cwd !== undefined) {
      writer.uint32(18).string(message.cwd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : undefined,
    };
  },

  toJSON(message: WorkspaceMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cwd !== undefined) {
      obj.cwd = message.cwd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceMetadata>, I>>(base?: I): WorkspaceMetadata {
    return WorkspaceMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceMetadata>, I>>(object: I): WorkspaceMetadata {
    const message = createBaseWorkspaceMetadata();
    message.name = object.name ?? "";
    message.cwd = object.cwd ?? undefined;
    return message;
  },
};

function createBaseJournalEntriesRequest(): JournalEntriesRequest {
  return { journal: "", ranges: [] };
}

export const JournalEntriesRequest: MessageFns<JournalEntriesRequest> = {
  encode(message: JournalEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.journal !== "") {
      writer.uint32(10).string(message.journal);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JournalEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJournalEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.journal = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JournalEntriesRequest {
    return {
      journal: isSet(object.journal) ? globalThis.String(object.journal) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: JournalEntriesRequest): unknown {
    const obj: any = {};
    if (message.journal !== "") {
      obj.journal = message.journal;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JournalEntriesRequest>, I>>(base?: I): JournalEntriesRequest {
    return JournalEntriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JournalEntriesRequest>, I>>(object: I): JournalEntriesRequest {
    const message = createBaseJournalEntriesRequest();
    message.journal = object.journal ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRange(): Range {
  return { start: 0, end: 0 };
}

export const Range: MessageFns<Range> = {
  encode(message: Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).uint64(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).uint64(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.end = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Range {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: Range): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Range>, I>>(base?: I): Range {
    return Range.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Range>, I>>(object: I): Range {
    const message = createBaseRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseJournalEntriesResponse(): JournalEntriesResponse {
  return { entries: {} };
}

export const JournalEntriesResponse: MessageFns<JournalEntriesResponse> = {
  encode(message: JournalEntriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.entries).forEach(([key, value]) => {
      JournalEntriesResponse_EntriesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JournalEntriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJournalEntriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = JournalEntriesResponse_EntriesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.entries[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JournalEntriesResponse {
    return {
      entries: isObject(object.entries)
        ? Object.entries(object.entries).reduce<{ [key: number]: JournalEntry }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = JournalEntry.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: JournalEntriesResponse): unknown {
    const obj: any = {};
    if (message.entries) {
      const entries = Object.entries(message.entries);
      if (entries.length > 0) {
        obj.entries = {};
        entries.forEach(([k, v]) => {
          obj.entries[k] = JournalEntry.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JournalEntriesResponse>, I>>(base?: I): JournalEntriesResponse {
    return JournalEntriesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JournalEntriesResponse>, I>>(object: I): JournalEntriesResponse {
    const message = createBaseJournalEntriesResponse();
    message.entries = Object.entries(object.entries ?? {}).reduce<{ [key: number]: JournalEntry }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = JournalEntry.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseJournalEntriesResponse_EntriesEntry(): JournalEntriesResponse_EntriesEntry {
  return { key: 0, value: undefined };
}

export const JournalEntriesResponse_EntriesEntry: MessageFns<JournalEntriesResponse_EntriesEntry> = {
  encode(message: JournalEntriesResponse_EntriesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint64(message.key);
    }
    if (message.value !== undefined) {
      JournalEntry.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JournalEntriesResponse_EntriesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJournalEntriesResponse_EntriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = JournalEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JournalEntriesResponse_EntriesEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? JournalEntry.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: JournalEntriesResponse_EntriesEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = JournalEntry.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JournalEntriesResponse_EntriesEntry>, I>>(
    base?: I,
  ): JournalEntriesResponse_EntriesEntry {
    return JournalEntriesResponse_EntriesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JournalEntriesResponse_EntriesEntry>, I>>(
    object: I,
  ): JournalEntriesResponse_EntriesEntry {
    const message = createBaseJournalEntriesResponse_EntriesEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? JournalEntry.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseJournalEntry(): JournalEntry {
  return { ts: 0, level: 0, workspace: undefined, service: undefined, message: undefined, fields: new Uint8Array(0) };
}

export const JournalEntry: MessageFns<JournalEntry> = {
  encode(message: JournalEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ts !== 0) {
      writer.uint32(8).uint64(message.ts);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint64(message.level);
    }
    if (message.workspace !== undefined) {
      writer.uint32(26).string(message.workspace);
    }
    if (message.service !== undefined) {
      writer.uint32(34).string(message.service);
    }
    if (message.message !== undefined) {
      writer.uint32(42).string(message.message);
    }
    if (message.fields.length !== 0) {
      writer.uint32(50).bytes(message.fields);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JournalEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJournalEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ts = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workspace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fields = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JournalEntry {
    return {
      ts: isSet(object.ts) ? globalThis.Number(object.ts) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      workspace: isSet(object.workspace) ? globalThis.String(object.workspace) : undefined,
      service: isSet(object.service) ? globalThis.String(object.service) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      fields: isSet(object.fields) ? bytesFromBase64(object.fields) : new Uint8Array(0),
    };
  },

  toJSON(message: JournalEntry): unknown {
    const obj: any = {};
    if (message.ts !== 0) {
      obj.ts = Math.round(message.ts);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.workspace !== undefined) {
      obj.workspace = message.workspace;
    }
    if (message.service !== undefined) {
      obj.service = message.service;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.fields.length !== 0) {
      obj.fields = base64FromBytes(message.fields);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JournalEntry>, I>>(base?: I): JournalEntry {
    return JournalEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JournalEntry>, I>>(object: I): JournalEntry {
    const message = createBaseJournalEntry();
    message.ts = object.ts ?? 0;
    message.level = object.level ?? 0;
    message.workspace = object.workspace ?? undefined;
    message.service = object.service ?? undefined;
    message.message = object.message ?? undefined;
    message.fields = object.fields ?? new Uint8Array(0);
    return message;
  },
};

function createBaseJournalRequest(): JournalRequest {
  return { workspace: "", service: undefined, query: undefined };
}

export const JournalRequest: MessageFns<JournalRequest> = {
  encode(message: JournalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== "") {
      writer.uint32(10).string(message.workspace);
    }
    if (message.service !== undefined) {
      writer.uint32(18).string(message.service);
    }
    if (message.query !== undefined) {
      writer.uint32(26).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JournalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJournalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JournalRequest {
    return {
      workspace: isSet(object.workspace) ? globalThis.String(object.workspace) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : undefined,
    };
  },

  toJSON(message: JournalRequest): unknown {
    const obj: any = {};
    if (message.workspace !== "") {
      obj.workspace = message.workspace;
    }
    if (message.service !== undefined) {
      obj.service = message.service;
    }
    if (message.query !== undefined) {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JournalRequest>, I>>(base?: I): JournalRequest {
    return JournalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JournalRequest>, I>>(object: I): JournalRequest {
    const message = createBaseJournalRequest();
    message.workspace = object.workspace ?? "";
    message.service = object.service ?? undefined;
    message.query = object.query ?? undefined;
    return message;
  },
};

function createBaseJournalRecord(): JournalRecord {
  return { uuid: "", length: 0 };
}

export const JournalRecord: MessageFns<JournalRecord> = {
  encode(message: JournalRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.length !== 0) {
      writer.uint32(16).uint64(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JournalRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJournalRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JournalRecord {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: JournalRecord): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JournalRecord>, I>>(base?: I): JournalRecord {
    return JournalRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JournalRecord>, I>>(object: I): JournalRecord {
    const message = createBaseJournalRecord();
    message.uuid = object.uuid ?? "";
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseTreeRequest(): TreeRequest {
  return {};
}

export const TreeRequest: MessageFns<TreeRequest> = {
  encode(_: TreeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TreeRequest {
    return {};
  },

  toJSON(_: TreeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeRequest>, I>>(base?: I): TreeRequest {
    return TreeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeRequest>, I>>(_: I): TreeRequest {
    const message = createBaseTreeRequest();
    return message;
  },
};

function createBaseTreeResponse(): TreeResponse {
  return { workspaces: [] };
}

export const TreeResponse: MessageFns<TreeResponse> = {
  encode(message: TreeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workspaces) {
      TreeWorkspace.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspaces.push(TreeWorkspace.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeResponse {
    return {
      workspaces: globalThis.Array.isArray(object?.workspaces)
        ? object.workspaces.map((e: any) => TreeWorkspace.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TreeResponse): unknown {
    const obj: any = {};
    if (message.workspaces?.length) {
      obj.workspaces = message.workspaces.map((e) => TreeWorkspace.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeResponse>, I>>(base?: I): TreeResponse {
    return TreeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeResponse>, I>>(object: I): TreeResponse {
    const message = createBaseTreeResponse();
    message.workspaces = object.workspaces?.map((e) => TreeWorkspace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTreeWorkspace(): TreeWorkspace {
  return { name: "", processes: [], services: [] };
}

export const TreeWorkspace: MessageFns<TreeWorkspace> = {
  encode(message: TreeWorkspace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.processes) {
      TreeProcess.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.services) {
      TreeService.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeWorkspace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeWorkspace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.processes.push(TreeProcess.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.services.push(TreeService.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeWorkspace {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      processes: globalThis.Array.isArray(object?.processes)
        ? object.processes.map((e: any) => TreeProcess.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => TreeService.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TreeWorkspace): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.processes?.length) {
      obj.processes = message.processes.map((e) => TreeProcess.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => TreeService.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeWorkspace>, I>>(base?: I): TreeWorkspace {
    return TreeWorkspace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeWorkspace>, I>>(object: I): TreeWorkspace {
    const message = createBaseTreeWorkspace();
    message.name = object.name ?? "";
    message.processes = object.processes?.map((e) => TreeProcess.fromPartial(e)) || [];
    message.services = object.services?.map((e) => TreeService.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTreeService(): TreeService {
  return { name: "", flags: 0, processes: [] };
}

export const TreeService: MessageFns<TreeService> = {
  encode(message: TreeService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.flags !== 0) {
      writer.uint32(16).uint64(message.flags);
    }
    for (const v of message.processes) {
      TreeProcess.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flags = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processes.push(TreeProcess.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeService {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      processes: globalThis.Array.isArray(object?.processes)
        ? object.processes.map((e: any) => TreeProcess.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TreeService): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.processes?.length) {
      obj.processes = message.processes.map((e) => TreeProcess.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeService>, I>>(base?: I): TreeService {
    return TreeService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeService>, I>>(object: I): TreeService {
    const message = createBaseTreeService();
    message.name = object.name ?? "";
    message.flags = object.flags ?? 0;
    message.processes = object.processes?.map((e) => TreeProcess.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTreeProcess(): TreeProcess {
  return { name: "", pid: 0, restartCount: 0, lastRestart: undefined, flags: 0 };
}

export const TreeProcess: MessageFns<TreeProcess> = {
  encode(message: TreeProcess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pid !== 0) {
      writer.uint32(16).uint64(message.pid);
    }
    if (message.restartCount !== 0) {
      writer.uint32(24).uint64(message.restartCount);
    }
    if (message.lastRestart !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRestart), writer.uint32(34).fork()).join();
    }
    if (message.flags !== 0) {
      writer.uint32(40).uint64(message.flags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeProcess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeProcess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pid = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.restartCount = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastRestart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.flags = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeProcess {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      restartCount: isSet(object.restartCount) ? globalThis.Number(object.restartCount) : 0,
      lastRestart: isSet(object.lastRestart) ? fromJsonTimestamp(object.lastRestart) : undefined,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: TreeProcess): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.restartCount !== 0) {
      obj.restartCount = Math.round(message.restartCount);
    }
    if (message.lastRestart !== undefined) {
      obj.lastRestart = message.lastRestart.toISOString();
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeProcess>, I>>(base?: I): TreeProcess {
    return TreeProcess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeProcess>, I>>(object: I): TreeProcess {
    const message = createBaseTreeProcess();
    message.name = object.name ?? "";
    message.pid = object.pid ?? 0;
    message.restartCount = object.restartCount ?? 0;
    message.lastRestart = object.lastRestart ?? undefined;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBaseFlag(): Flag {
  return { label: "", value: undefined };
}

export const Flag: MessageFns<Flag> = {
  encode(message: Flag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Flag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Flag {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: Flag): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Flag>, I>>(base?: I): Flag {
    return Flag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Flag>, I>>(object: I): Flag {
    const message = createBaseFlag();
    message.label = object.label ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseExecRequest(): ExecRequest {
  return { folder: "", watch: false, uuid: undefined, extra: undefined, start: undefined };
}

export const ExecRequest: MessageFns<ExecRequest> = {
  encode(message: ExecRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.folder !== "") {
      writer.uint32(10).string(message.folder);
    }
    if (message.watch !== false) {
      writer.uint32(24).bool(message.watch);
    }
    if (message.uuid !== undefined) {
      writer.uint32(34).string(message.uuid);
    }
    if (message.extra !== undefined) {
      writer.uint32(42).bytes(message.extra);
    }
    if (message.start !== undefined) {
      StartCommand.encode(message.start, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.folder = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.watch = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extra = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.start = StartCommand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecRequest {
    return {
      folder: isSet(object.folder) ? globalThis.String(object.folder) : "",
      watch: isSet(object.watch) ? globalThis.Boolean(object.watch) : false,
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : undefined,
      extra: isSet(object.extra) ? bytesFromBase64(object.extra) : undefined,
      start: isSet(object.start) ? StartCommand.fromJSON(object.start) : undefined,
    };
  },

  toJSON(message: ExecRequest): unknown {
    const obj: any = {};
    if (message.folder !== "") {
      obj.folder = message.folder;
    }
    if (message.watch !== false) {
      obj.watch = message.watch;
    }
    if (message.uuid !== undefined) {
      obj.uuid = message.uuid;
    }
    if (message.extra !== undefined) {
      obj.extra = base64FromBytes(message.extra);
    }
    if (message.start !== undefined) {
      obj.start = StartCommand.toJSON(message.start);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecRequest>, I>>(base?: I): ExecRequest {
    return ExecRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecRequest>, I>>(object: I): ExecRequest {
    const message = createBaseExecRequest();
    message.folder = object.folder ?? "";
    message.watch = object.watch ?? false;
    message.uuid = object.uuid ?? undefined;
    message.extra = object.extra ?? undefined;
    message.start = (object.start !== undefined && object.start !== null)
      ? StartCommand.fromPartial(object.start)
      : undefined;
    return message;
  },
};

function createBaseStartCommand(): StartCommand {
  return { workspace: undefined, process: undefined };
}

export const StartCommand: MessageFns<StartCommand> = {
  encode(message: StartCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== undefined) {
      WorkspaceMetadata.encode(message.workspace, writer.uint32(18).fork()).join();
    }
    if (message.process !== undefined) {
      ProcessMetadata.encode(message.process, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workspace = WorkspaceMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.process = ProcessMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartCommand {
    return {
      workspace: isSet(object.workspace) ? WorkspaceMetadata.fromJSON(object.workspace) : undefined,
      process: isSet(object.process) ? ProcessMetadata.fromJSON(object.process) : undefined,
    };
  },

  toJSON(message: StartCommand): unknown {
    const obj: any = {};
    if (message.workspace !== undefined) {
      obj.workspace = WorkspaceMetadata.toJSON(message.workspace);
    }
    if (message.process !== undefined) {
      obj.process = ProcessMetadata.toJSON(message.process);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartCommand>, I>>(base?: I): StartCommand {
    return StartCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartCommand>, I>>(object: I): StartCommand {
    const message = createBaseStartCommand();
    message.workspace = (object.workspace !== undefined && object.workspace !== null)
      ? WorkspaceMetadata.fromPartial(object.workspace)
      : undefined;
    message.process = (object.process !== undefined && object.process !== null)
      ? ProcessMetadata.fromPartial(object.process)
      : undefined;
    return message;
  },
};

function createBaseClearJournalRequest(): ClearJournalRequest {
  return {};
}

export const ClearJournalRequest: MessageFns<ClearJournalRequest> = {
  encode(_: ClearJournalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearJournalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearJournalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearJournalRequest {
    return {};
  },

  toJSON(_: ClearJournalRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearJournalRequest>, I>>(base?: I): ClearJournalRequest {
    return ClearJournalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearJournalRequest>, I>>(_: I): ClearJournalRequest {
    const message = createBaseClearJournalRequest();
    return message;
  },
};

function createBaseClearJournalResponse(): ClearJournalResponse {
  return {};
}

export const ClearJournalResponse: MessageFns<ClearJournalResponse> = {
  encode(_: ClearJournalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearJournalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearJournalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearJournalResponse {
    return {};
  },

  toJSON(_: ClearJournalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearJournalResponse>, I>>(base?: I): ClearJournalResponse {
    return ClearJournalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearJournalResponse>, I>>(_: I): ClearJournalResponse {
    const message = createBaseClearJournalResponse();
    return message;
  },
};

function createBaseTerminateRequest(): TerminateRequest {
  return {};
}

export const TerminateRequest: MessageFns<TerminateRequest> = {
  encode(_: TerminateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TerminateRequest {
    return {};
  },

  toJSON(_: TerminateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TerminateRequest>, I>>(base?: I): TerminateRequest {
    return TerminateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TerminateRequest>, I>>(_: I): TerminateRequest {
    const message = createBaseTerminateRequest();
    return message;
  },
};

function createBaseTerminateResponse(): TerminateResponse {
  return {};
}

export const TerminateResponse: MessageFns<TerminateResponse> = {
  encode(_: TerminateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TerminateResponse {
    return {};
  },

  toJSON(_: TerminateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TerminateResponse>, I>>(base?: I): TerminateResponse {
    return TerminateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TerminateResponse>, I>>(_: I): TerminateResponse {
    const message = createBaseTerminateResponse();
    return message;
  },
};

function createBaseVersionRequest(): VersionRequest {
  return {};
}

export const VersionRequest: MessageFns<VersionRequest> = {
  encode(_: VersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VersionRequest {
    return {};
  },

  toJSON(_: VersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionRequest>, I>>(base?: I): VersionRequest {
    return VersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionRequest>, I>>(_: I): VersionRequest {
    const message = createBaseVersionRequest();
    return message;
  },
};

function createBaseCommandRecord(): CommandRecord {
  return { metadata: undefined, log: undefined, result: undefined };
}

export const CommandRecord: MessageFns<CommandRecord> = {
  encode(message: CommandRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.log !== undefined) {
      LogEntry.encode(message.log, writer.uint32(18).fork()).join();
    }
    if (message.result !== undefined) {
      JsonResult.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.log = LogEntry.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = JsonResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandRecord {
    return {
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      log: isSet(object.log) ? LogEntry.fromJSON(object.log) : undefined,
      result: isSet(object.result) ? JsonResult.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: CommandRecord): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.log !== undefined) {
      obj.log = LogEntry.toJSON(message.log);
    }
    if (message.result !== undefined) {
      obj.result = JsonResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandRecord>, I>>(base?: I): CommandRecord {
    return CommandRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandRecord>, I>>(object: I): CommandRecord {
    const message = createBaseCommandRecord();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.log = (object.log !== undefined && object.log !== null) ? LogEntry.fromPartial(object.log) : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? JsonResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseJsonResult(): JsonResult {
  return { value: new Uint8Array(0), error: undefined };
}

export const JsonResult: MessageFns<JsonResult> = {
  encode(message: JsonResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message.error !== undefined) {
      JsonError.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = JsonError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonResult {
    return {
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      error: isSet(object.error) ? JsonError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: JsonResult): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.error !== undefined) {
      obj.error = JsonError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonResult>, I>>(base?: I): JsonResult {
    return JsonResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonResult>, I>>(object: I): JsonResult {
    const message = createBaseJsonResult();
    message.value = object.value ?? new Uint8Array(0);
    message.error = (object.error !== undefined && object.error !== null)
      ? JsonError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseJsonError(): JsonError {
  return { code: "", message: "", source: undefined, backtrace: [] };
}

export const JsonError: MessageFns<JsonError> = {
  encode(message: JsonError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.source !== undefined) {
      JsonError.encode(message.source, writer.uint32(26).fork()).join();
    }
    for (const v of message.backtrace) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = JsonError.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.backtrace.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      source: isSet(object.source) ? JsonError.fromJSON(object.source) : undefined,
      backtrace: globalThis.Array.isArray(object?.backtrace)
        ? object.backtrace.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: JsonError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.source !== undefined) {
      obj.source = JsonError.toJSON(message.source);
    }
    if (message.backtrace?.length) {
      obj.backtrace = message.backtrace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonError>, I>>(base?: I): JsonError {
    return JsonError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonError>, I>>(object: I): JsonError {
    const message = createBaseJsonError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? JsonError.fromPartial(object.source)
      : undefined;
    message.backtrace = object.backtrace?.map((e) => e) || [];
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return {};
}

export const Metadata: MessageFns<Metadata> = {
  encode(_: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Metadata {
    return {};
  },

  toJSON(_: Metadata): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(_: I): Metadata {
    const message = createBaseMetadata();
    return message;
  },
};

function createBaseLogEntry(): LogEntry {
  return {};
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(_: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogEntry {
    return {};
  },

  toJSON(_: LogEntry): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntry>, I>>(base?: I): LogEntry {
    return LogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntry>, I>>(_: I): LogEntry {
    const message = createBaseLogEntry();
    return message;
  },
};

function createBaseVersionResponse(): VersionResponse {
  return { version: "" };
}

export const VersionResponse: MessageFns<VersionResponse> = {
  encode(message: VersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionResponse {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: VersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionResponse>, I>>(base?: I): VersionResponse {
    return VersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionResponse>, I>>(object: I): VersionResponse {
    const message = createBaseVersionResponse();
    message.version = object.version ?? "";
    return message;
  },
};

/** Service mapping the GraphQL RunySubscription */
export type RunyService = typeof RunyService;
export const RunyService = {
  terminate: {
    path: "/runy.Runy/Terminate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TerminateRequest): Buffer => Buffer.from(TerminateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TerminateRequest => TerminateRequest.decode(value),
    responseSerialize: (value: TerminateResponse): Buffer => Buffer.from(TerminateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TerminateResponse => TerminateResponse.decode(value),
  },
  version: {
    path: "/runy.Runy/Version",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VersionRequest): Buffer => Buffer.from(VersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VersionRequest => VersionRequest.decode(value),
    responseSerialize: (value: VersionResponse): Buffer => Buffer.from(VersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VersionResponse => VersionResponse.decode(value),
  },
  command: {
    path: "/runy.Runy/Command",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExecRequest): Buffer => Buffer.from(ExecRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecRequest => ExecRequest.decode(value),
    responseSerialize: (value: CommandRecord): Buffer => Buffer.from(CommandRecord.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommandRecord => CommandRecord.decode(value),
  },
  clearJournal: {
    path: "/runy.Runy/ClearJournal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearJournalRequest): Buffer => Buffer.from(ClearJournalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ClearJournalRequest => ClearJournalRequest.decode(value),
    responseSerialize: (value: ClearJournalResponse): Buffer =>
      Buffer.from(ClearJournalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClearJournalResponse => ClearJournalResponse.decode(value),
  },
  tree: {
    path: "/runy.Runy/Tree",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TreeRequest): Buffer => Buffer.from(TreeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TreeRequest => TreeRequest.decode(value),
    responseSerialize: (value: TreeResponse): Buffer => Buffer.from(TreeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TreeResponse => TreeResponse.decode(value),
  },
  journal: {
    path: "/runy.Runy/Journal",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: JournalRequest): Buffer => Buffer.from(JournalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): JournalRequest => JournalRequest.decode(value),
    responseSerialize: (value: JournalRecord): Buffer => Buffer.from(JournalRecord.encode(value).finish()),
    responseDeserialize: (value: Buffer): JournalRecord => JournalRecord.decode(value),
  },
  journalEntries: {
    path: "/runy.Runy/JournalEntries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: JournalEntriesRequest): Buffer =>
      Buffer.from(JournalEntriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): JournalEntriesRequest => JournalEntriesRequest.decode(value),
    responseSerialize: (value: JournalEntriesResponse): Buffer =>
      Buffer.from(JournalEntriesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): JournalEntriesResponse => JournalEntriesResponse.decode(value),
  },
  workspaceCreate: {
    path: "/runy.Runy/WorkspaceCreate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WorkspaceCreateRequest): Buffer =>
      Buffer.from(WorkspaceCreateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): WorkspaceCreateRequest => WorkspaceCreateRequest.decode(value),
    responseSerialize: (value: WorkspaceCreateResponse): Buffer =>
      Buffer.from(WorkspaceCreateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): WorkspaceCreateResponse => WorkspaceCreateResponse.decode(value),
  },
  workspaceRemove: {
    path: "/runy.Runy/WorkspaceRemove",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WorkspaceRemoveRequest): Buffer =>
      Buffer.from(WorkspaceRemoveRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): WorkspaceRemoveRequest => WorkspaceRemoveRequest.decode(value),
    responseSerialize: (value: WorkspaceRemoveResponse): Buffer =>
      Buffer.from(WorkspaceRemoveResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): WorkspaceRemoveResponse => WorkspaceRemoveResponse.decode(value),
  },
  signal: {
    path: "/runy.Runy/Signal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignalRequest): Buffer => Buffer.from(SignalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignalRequest => SignalRequest.decode(value),
    responseSerialize: (value: SignalResponse): Buffer => Buffer.from(SignalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignalResponse => SignalResponse.decode(value),
  },
  getResource: {
    path: "/runy.Runy/GetResource",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetResourceRequest): Buffer => Buffer.from(GetResourceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetResourceRequest => GetResourceRequest.decode(value),
    responseSerialize: (value: GetResourceResponse): Buffer => Buffer.from(GetResourceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetResourceResponse => GetResourceResponse.decode(value),
  },
  reconfigure: {
    path: "/runy.Runy/Reconfigure",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReconfigureRequest): Buffer => Buffer.from(ReconfigureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReconfigureRequest => ReconfigureRequest.decode(value),
    responseSerialize: (value: ReconfigureResponse): Buffer => Buffer.from(ReconfigureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReconfigureResponse => ReconfigureResponse.decode(value),
  },
} as const;

export interface RunyServer extends UntypedServiceImplementation {
  terminate: handleUnaryCall<TerminateRequest, TerminateResponse>;
  version: handleUnaryCall<VersionRequest, VersionResponse>;
  command: handleServerStreamingCall<ExecRequest, CommandRecord>;
  clearJournal: handleUnaryCall<ClearJournalRequest, ClearJournalResponse>;
  tree: handleServerStreamingCall<TreeRequest, TreeResponse>;
  journal: handleServerStreamingCall<JournalRequest, JournalRecord>;
  journalEntries: handleUnaryCall<JournalEntriesRequest, JournalEntriesResponse>;
  workspaceCreate: handleUnaryCall<WorkspaceCreateRequest, WorkspaceCreateResponse>;
  workspaceRemove: handleUnaryCall<WorkspaceRemoveRequest, WorkspaceRemoveResponse>;
  signal: handleUnaryCall<SignalRequest, SignalResponse>;
  getResource: handleUnaryCall<GetResourceRequest, GetResourceResponse>;
  reconfigure: handleUnaryCall<ReconfigureRequest, ReconfigureResponse>;
}

export interface RunyClient extends Client {
  terminate(
    request: TerminateRequest,
    callback: (error: ServiceError | null, response: TerminateResponse) => void,
  ): ClientUnaryCall;
  terminate(
    request: TerminateRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: TerminateResponse) => void,
  ): ClientUnaryCall;
  terminate(
    request: TerminateRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TerminateResponse) => void,
  ): ClientUnaryCall;
  version(
    request: VersionRequest,
    callback: (error: ServiceError | null, response: VersionResponse) => void,
  ): ClientUnaryCall;
  version(
    request: VersionRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: VersionResponse) => void,
  ): ClientUnaryCall;
  version(
    request: VersionRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VersionResponse) => void,
  ): ClientUnaryCall;
  command(request: ExecRequest, options?: Partial<CallOptions>): ClientReadableStream<CommandRecord>;
  command(
    request: ExecRequest,
    metadata?: Metadata1,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<CommandRecord>;
  clearJournal(
    request: ClearJournalRequest,
    callback: (error: ServiceError | null, response: ClearJournalResponse) => void,
  ): ClientUnaryCall;
  clearJournal(
    request: ClearJournalRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: ClearJournalResponse) => void,
  ): ClientUnaryCall;
  clearJournal(
    request: ClearJournalRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClearJournalResponse) => void,
  ): ClientUnaryCall;
  tree(request: TreeRequest, options?: Partial<CallOptions>): ClientReadableStream<TreeResponse>;
  tree(request: TreeRequest, metadata?: Metadata1, options?: Partial<CallOptions>): ClientReadableStream<TreeResponse>;
  journal(request: JournalRequest, options?: Partial<CallOptions>): ClientReadableStream<JournalRecord>;
  journal(
    request: JournalRequest,
    metadata?: Metadata1,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<JournalRecord>;
  journalEntries(
    request: JournalEntriesRequest,
    callback: (error: ServiceError | null, response: JournalEntriesResponse) => void,
  ): ClientUnaryCall;
  journalEntries(
    request: JournalEntriesRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: JournalEntriesResponse) => void,
  ): ClientUnaryCall;
  journalEntries(
    request: JournalEntriesRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: JournalEntriesResponse) => void,
  ): ClientUnaryCall;
  workspaceCreate(
    request: WorkspaceCreateRequest,
    callback: (error: ServiceError | null, response: WorkspaceCreateResponse) => void,
  ): ClientUnaryCall;
  workspaceCreate(
    request: WorkspaceCreateRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: WorkspaceCreateResponse) => void,
  ): ClientUnaryCall;
  workspaceCreate(
    request: WorkspaceCreateRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WorkspaceCreateResponse) => void,
  ): ClientUnaryCall;
  workspaceRemove(
    request: WorkspaceRemoveRequest,
    callback: (error: ServiceError | null, response: WorkspaceRemoveResponse) => void,
  ): ClientUnaryCall;
  workspaceRemove(
    request: WorkspaceRemoveRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: WorkspaceRemoveResponse) => void,
  ): ClientUnaryCall;
  workspaceRemove(
    request: WorkspaceRemoveRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WorkspaceRemoveResponse) => void,
  ): ClientUnaryCall;
  signal(
    request: SignalRequest,
    callback: (error: ServiceError | null, response: SignalResponse) => void,
  ): ClientUnaryCall;
  signal(
    request: SignalRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: SignalResponse) => void,
  ): ClientUnaryCall;
  signal(
    request: SignalRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignalResponse) => void,
  ): ClientUnaryCall;
  getResource(
    request: GetResourceRequest,
    callback: (error: ServiceError | null, response: GetResourceResponse) => void,
  ): ClientUnaryCall;
  getResource(
    request: GetResourceRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: GetResourceResponse) => void,
  ): ClientUnaryCall;
  getResource(
    request: GetResourceRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResourceResponse) => void,
  ): ClientUnaryCall;
  reconfigure(
    request: ReconfigureRequest,
    callback: (error: ServiceError | null, response: ReconfigureResponse) => void,
  ): ClientUnaryCall;
  reconfigure(
    request: ReconfigureRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: ReconfigureResponse) => void,
  ): ClientUnaryCall;
  reconfigure(
    request: ReconfigureRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReconfigureResponse) => void,
  ): ClientUnaryCall;
}

export const RunyClient = makeGenericClientConstructor(RunyService, "runy.Runy") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RunyClient;
  service: typeof RunyService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
